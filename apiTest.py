# -*- coding: utf-8 -*-
"""api 실험.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XcsDjDn83vZPEpQ-wQKO5b-BSY4Gnhg5
"""

import requests
import json


class ClovaSpeechClient:
    # Clova Speech invoke URL
    invoke_url = 'https://clovaspeech-gw.ncloud.com/external/v1/8749/90e770d5b5adf68d9e2fc484ee680fa7a69fb40540bcffe37be6c6921dcd6a42'
    # Clova Speech secret key
    secret = 'd569e2e69b9543928bceac30ce2fe43c'

    def req_url(self, url, completion, callback=None, userdata=None, forbiddens=None, boostings=None, wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'url': url,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/url',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_object_storage(self, data_key, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                           wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'dataKey': data_key,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/object-storage',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_upload(self, file, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                   wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        print(json.dumps(request_body, ensure_ascii=False).encode('UTF-8'))
        files = {
            'media': open(file, 'rb'),
            'params': (None, json.dumps(request_body, ensure_ascii=False).encode('UTF-8'), 'application/json')
        }
        response = requests.post(headers=headers, url=self.invoke_url + '/recognizer/upload', files=files)
        return response

if __name__ == '__main__':

    #외부 URL 사용
    # res = ClovaSpeechClient().req_url(url='http://example.com/media.mp3', completion='sync')

    #클라우드 스토리지에 있는 파일 사용
    # res = ClovaSpeechClient().req_object_storage(data_key='data/media.mp3', completion='sync')

    #로컬 저장소에 있는 파일 사용
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')
    print(res.text)

if __name__ == '__main__':
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')
    result = res.json()

    # Extract speaker-segmented results
    segments = result.get('segments', [])
    speaker_segments = []
    for segment in segments:
        speaker_label = segment['speaker']['label']
        text = segment['text']
        speaker_segments.append({'speaker': speaker_label, 'text': text})

    # Print speaker-segmented results
    for speaker_segment in speaker_segments:
        speaker_label = speaker_segment['speaker']
        text = speaker_segment['text']
        print(f'Speaker {speaker_label}: {text}')


    # txt로 뽑아내기

import requests
import json


class ClovaSpeechClient:
    # Clova Speech invoke URL
    invoke_url = 'https://clovaspeech-gw.ncloud.com/external/v1/8749/90e770d5b5adf68d9e2fc484ee680fa7a69fb40540bcffe37be6c6921dcd6a42'
    # Clova Speech secret key
    secret = 'd569e2e69b9543928bceac30ce2fe43c'

    def req_url(self, url, completion, callback=None, userdata=None, forbiddens=None, boostings=None, wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'url': url,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/url',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_object_storage(self, data_key, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                           wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'dataKey': data_key,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/object-storage',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_upload(self, file, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                   wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        print(json.dumps(request_body, ensure_ascii=False).encode('UTF-8'))
        files = {
            'media': open(file, 'rb'),
            'params': (None, json.dumps(request_body, ensure_ascii=False).encode('UTF-8'), 'application/json')
        }
        response = requests.post(headers=headers, url=self.invoke_url + '/recognizer/upload', files=files)
        return response

    # JSON 파일로 저장하는 함수
    def save_response_to_json(self, response, filename):
        try:
            # 응답을 JSON 형태로 파싱
            response_json = response.json()
            # JSON 데이터를 파일로 저장
            with open(filename, 'w', encoding='utf-8') as json_file:
                json.dump(response_json, json_file, ensure_ascii=False, indent=4)
            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"JSON 저장 중 오류가 발생했습니다: {e}")


if __name__ == '__main__':

    # 외부 URL 사용
    # res = ClovaSpeechClient().req_url(url='http://example.com/media.mp3', completion='sync')

    # 클라우드 스토리지에 있는 파일 사용
    # res = ClovaSpeechClient().req_object_storage(data_key='data/media.mp3', completion='sync')

    # 로컬 저장소에 있는 파일 사용
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')

    # 응답을 JSON 파일로 저장
    ClovaSpeechClient().save_response_to_json(res, 'response.json')
    print(res.text)

import requests
import json


class ClovaSpeechClient:
    # Clova Speech invoke URL
    invoke_url = 'https://clovaspeech-gw.ncloud.com/external/v1/8749/90e770d5b5adf68d9e2fc484ee680fa7a69fb40540bcffe37be6c6921dcd6a42'
    # Clova Speech secret key
    secret = 'd569e2e69b9543928bceac30ce2fe43c'

    def req_url(self, url, completion, callback=None, userdata=None, forbiddens=None, boostings=None, wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'url': url,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/url',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_object_storage(self, data_key, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                           wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'dataKey': data_key,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/object-storage',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_upload(self, file, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                   wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        print(json.dumps(request_body, ensure_ascii=False).encode('UTF-8'))
        files = {
            'media': open(file, 'rb'),
            'params': (None, json.dumps(request_body, ensure_ascii=False).encode('UTF-8'), 'application/json')
        }
        response = requests.post(headers=headers, url=self.invoke_url + '/recognizer/upload', files=files)
        return response

    # JSON 파일로 저장하는 함수
    def save_response_to_json(self, response, filename):
        try:
            # 응답을 JSON 형태로 파싱
            response_json = response.json()
            # JSON 데이터를 파일로 저장
            with open(filename, 'w', encoding='utf-8') as json_file:
                json.dump(response_json, json_file, ensure_ascii=False, indent=4)
            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"JSON 저장 중 오류가 발생했습니다: {e}")

    # SRT 파일로 저장하는 함수
    def save_response_to_srt(self, response, filename):
        try:
            response_json = response.json()

            # SRT 파일을 생성
            with open(filename, 'w', encoding='utf-8') as srt_file:
                index = 1

                # Transcription segments를 순회하며 SRT 형식으로 변환
                for segment in response_json.get('segments', []):
                    start_time = segment['start']
                    end_time = segment['end']
                    text = segment['text']

                    # 시간 포맷 변환 (milliseconds to hours:minutes:seconds,milliseconds)
                    start_time_srt = self.convert_millis_to_srt_time(start_time)
                    end_time_srt = self.convert_millis_to_srt_time(end_time)

                    # SRT 파일에 작성
                    srt_file.write(f"{index}\n")
                    srt_file.write(f"{start_time_srt} --> {end_time_srt}\n")
                    srt_file.write(f"{text}\n\n")
                    index += 1

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"SRT 저장 중 오류가 발생했습니다: {e}")

    # 밀리초를 SRT 시간 형식으로 변환하는 함수
    @staticmethod
    def convert_millis_to_srt_time(millis):
        seconds, milliseconds = divmod(millis, 1000)
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        return f"{int(hours):02}:{int(minutes):02}:{int(seconds):02},{int(milliseconds):03}"


if __name__ == '__main__':
    # 외부 URL 사용
    # res = ClovaSpeechClient().req_url(url='http://example.com/media.mp3', completion='sync')

    # 클라우드 스토리지에 있는 파일 사용
    # res = ClovaSpeechClient().req_object_storage(data_key='data/media.mp3', completion='sync')

    # 로컬 저장소에 있는 파일 사용
    # file = '비디오 제목'
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')

    # 응답을 JSON 파일로 저장
    ClovaSpeechClient().save_response_to_json(res, 'response.json')

    # 응답을 SRT 파일로 저장
    ClovaSpeechClient().save_response_to_srt(res, 'response.srt')

    print(res.text)

import requests
import json
import csv


class ClovaSpeechClient:
    # Clova Speech invoke URL
    invoke_url = 'https://clovaspeech-gw.ncloud.com/external/v1/8749/90e770d5b5adf68d9e2fc484ee680fa7a69fb40540bcffe37be6c6921dcd6a42'
    # Clova Speech secret key
    secret = 'd569e2e69b9543928bceac30ce2fe43c'

    def req_url(self, url, completion, callback=None, userdata=None, forbiddens=None, boostings=None, wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'url': url,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/url',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_object_storage(self, data_key, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                           wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'dataKey': data_key,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/object-storage',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_upload(self, file, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                   wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        print(json.dumps(request_body, ensure_ascii=False).encode('UTF-8'))
        files = {
            'media': open(file, 'rb'),
            'params': (None, json.dumps(request_body, ensure_ascii=False).encode('UTF-8'), 'application/json')
        }
        response = requests.post(headers=headers, url=self.invoke_url + '/recognizer/upload', files=files)
        return response

    # JSON 파일로 저장하는 함수
    def save_response_to_json(self, response, filename):
        try:
            # 응답을 JSON 형태로 파싱
            response_json = response.json()
            # JSON 데이터를 파일로 저장
            with open(filename, 'w', encoding='utf-8') as json_file:
                json.dump(response_json, json_file, ensure_ascii=False, indent=4)
            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"JSON 저장 중 오류가 발생했습니다: {e}")

    # SRT 파일로 저장하는 함수
    def save_response_to_srt(self, response, filename):
        try:
            response_json = response.json()

            # SRT 파일을 생성
            with open(filename, 'w', encoding='utf-8') as srt_file:
                index = 1

                # Transcription segments를 순회하며 SRT 형식으로 변환
                for segment in response_json.get('segments', []):
                    start_time = segment['start']
                    end_time = segment['end']
                    text = segment['text']

                    # 시간 포맷 변환 (milliseconds to hours:minutes:seconds,milliseconds)
                    start_time_srt = self.convert_millis_to_srt_time(start_time)
                    end_time_srt = self.convert_millis_to_srt_time(end_time)

                    # SRT 파일에 작성
                    srt_file.write(f"{index}\n")
                    srt_file.write(f"{start_time_srt} --> {end_time_srt}\n")
                    srt_file.write(f"{text}\n\n")
                    index += 1

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"SRT 저장 중 오류가 발생했습니다: {e}")

    # TXT 파일로 저장하는 함수
    def save_response_to_txt(self, response, filename):
        try:
            response_json = response.json()

            # TXT 파일을 생성
            with open(filename, 'w', encoding='utf-8') as txt_file:
                # 전체 텍스트를 결합하여 작성
                for segment in response_json.get('segments', []):
                    txt_file.write(segment['text'] + "\n")

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"TXT 저장 중 오류가 발생했습니다: {e}")

    # CSV 파일로 저장하는 함수
    def save_response_to_csv(self, response, filename):
        try:
            response_json = response.json()

            # CSV 파일을 생성
            with open(filename, 'w', newline='', encoding='utf-8') as csv_file:
                csv_writer = csv.writer(csv_file)

                # 헤더 작성
                csv_writer.writerow(['Index', 'Start Time', 'End Time', 'Text'])

                index = 1
                for segment in response_json.get('segments', []):
                    start_time_srt = self.convert_millis_to_srt_time(segment['start'])
                    end_time_srt = self.convert_millis_to_srt_time(segment['end'])
                    text = segment['text']

                    # CSV 파일에 작성
                    csv_writer.writerow([index, start_time_srt, end_time_srt, text])
                    index += 1

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"CSV 저장 중 오류가 발생했습니다: {e}")

    # 밀리초를 SRT 시간 형식으로 변환하는 함수
    @staticmethod
    def convert_millis_to_srt_time(millis):
        seconds, milliseconds = divmod(millis, 1000)
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        return f"{int(hours):02}:{int(minutes):02}:{int(seconds):02},{int(milliseconds):03}"


if __name__ == '__main__':
    # 외부 URL 사용
    # res = ClovaSpeechClient().req_url(url='http://example.com/media.mp3', completion='sync')

    # 클라우드 스토리지에 있는 파일 사용
    # res = ClovaSpeechClient().req_object_storage(data_key='data/media.mp3', completion='sync')

    # 로컬 저장소에 있는 파일 사용
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')

    # 응답을 JSON 파일로 저장
    ClovaSpeechClient().save_response_to_json(res, 'response.json')

    # 응답을 SRT 파일로 저장
    ClovaSpeechClient().save_response_to_srt(res, 'response.srt')

    # 응답을 TXT 파일로 저장
    ClovaSpeechClient().save_response_to_txt(res, 'response.txt')

    # 응답을 CSV 파일로 저장
    ClovaSpeechClient().save_response_to_csv(res, 'response.csv')

    print(res.text)

import requests
import json
import csv

class ClovaSpeechClient:
    invoke_url = 'https://clovaspeech-gw.ncloud.com/external/v1/8749/90e770d5b5adf68d9e2fc484ee680fa7a69fb40540bcffe37be6c6921dcd6a42'
    secret = 'd569e2e69b9543928bceac30ce2fe43c'

    def req_url(self, url, completion, callback=None, userdata=None, forbiddens=None, boostings=None, wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'url': url,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/url',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_object_storage(self, data_key, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                           wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'dataKey': data_key,
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'Content-Type': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        return requests.post(headers=headers,
                             url=self.invoke_url + '/recognizer/object-storage',
                             data=json.dumps(request_body).encode('UTF-8'))

    def req_upload(self, file, completion, callback=None, userdata=None, forbiddens=None, boostings=None,
                   wordAlignment=True, fullText=True, diarization=None, sed=None):
        request_body = {
            'language': 'ko-KR',
            'completion': completion,
            'callback': callback,
            'userdata': userdata,
            'wordAlignment': wordAlignment,
            'fullText': fullText,
            'forbiddens': forbiddens,
            'boostings': boostings,
            'diarization': diarization,
            'sed': sed,
        }
        headers = {
            'Accept': 'application/json;UTF-8',
            'X-CLOVASPEECH-API-KEY': self.secret
        }
        print(json.dumps(request_body, ensure_ascii=False).encode('UTF-8'))
        files = {
            'media': open(file, 'rb'),
            'params': (None, json.dumps(request_body, ensure_ascii=False).encode('UTF-8'), 'application/json')
        }
        response = requests.post(headers=headers, url=self.invoke_url + '/recognizer/upload', files=files)
        return response

    # JSON 파일로 저장하는 함수
    def save_response_to_json(self, response, filename):
        try:
            response_json = response.json()
            with open(filename, 'w', encoding='utf-8') as json_file:
                json.dump(response_json, json_file, ensure_ascii=False, indent=4)
            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"JSON 저장 중 오류가 발생했습니다: {e}")

    # SRT 파일로 저장하는 함수
    def save_response_to_srt(self, response, filename):
        try:
            response_json = response.json()
            with open(filename, 'w', encoding='utf-8') as srt_file:
                index = 1
                for segment in response_json.get('segments', []):
                    start_time = segment['start']
                    end_time = segment['end']
                    text = segment['text']

                    # DeepL API를 사용해 번역
                    text_en = DeepLTranslator().translate_text(text, 'EN')
                    text_ja = DeepLTranslator().translate_text(text, 'JA')
                    text_zh = DeepLTranslator().translate_text(text, 'ZH')

                    start_time_srt = self.convert_millis_to_srt_time(start_time)
                    end_time_srt = self.convert_millis_to_srt_time(end_time)

                    srt_file.write(f"{index}\n")
                    srt_file.write(f"{start_time_srt} --> {end_time_srt}\n")
                    srt_file.write(f"{text} (KO)\n{text_en} (EN)\n{text_ja} (JA)\n{text_zh} (ZH)\n\n")
                    index += 1

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"SRT 저장 중 오류가 발생했습니다: {e}")

    # TXT 파일로 저장하는 함수
    def save_response_to_txt(self, response, filename):
        try:
            response_json = response.json()
            with open(filename, 'w', encoding='utf-8') as txt_file:
                for segment in response_json.get('segments', []):
                    text = segment['text']

                    # DeepL API를 사용해 번역
                    text_en = DeepLTranslator().translate_text(text, 'EN')
                    text_ja = DeepLTranslator().translate_text(text, 'JA')
                    text_zh = DeepLTranslator().translate_text(text, 'ZH')

                    txt_file.write(f"{text} (KO)\n{text_en} (EN)\n{text_ja} (JA)\n{text_zh} (ZH)\n\n")

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"TXT 저장 중 오류가 발생했습니다: {e}")

    # CSV 파일로 저장하는 함수
    def save_response_to_csv(self, response, filename):
        try:
            response_json = response.json()
            with open(filename, 'w', newline='', encoding='utf-8') as csv_file:
                csv_writer = csv.writer(csv_file)
                csv_writer.writerow(['Index', 'Start Time', 'End Time', 'Text (KO)', 'Text (EN)', 'Text (JA)', 'Text (ZH)'])

                index = 1
                for segment in response_json.get('segments', []):
                    start_time_srt = self.convert_millis_to_srt_time(segment['start'])
                    end_time_srt = self.convert_millis_to_srt_time(segment['end'])
                    text = segment['text']

                    # DeepL API를 사용해 번역
                    text_en = DeepLTranslator().translate_text(text, 'EN')
                    text_ja = DeepLTranslator().translate_text(text, 'JA')
                    text_zh = DeepLTranslator().translate_text(text, 'ZH')

                    csv_writer.writerow([index, start_time_srt, end_time_srt, text, text_en, text_ja, text_zh])
                    index += 1

            print(f"응답이 {filename} 파일로 저장되었습니다.")
        except Exception as e:
            print(f"CSV 저장 중 오류가 발생했습니다: {e}")

    @staticmethod
    def convert_millis_to_srt_time(millis):
        seconds, milliseconds = divmod(millis, 1000)
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        return f"{int(hours):02}:{int(minutes):02}:{int(seconds):02},{int(milliseconds):03}"


class DeepLTranslator:
    api_url = "https://api-free.deepl.com/v2/translate"
    api_key = "5fd5c64a-b2ad-44f2-8a93-8c10feb72aac:fx"  #deepL api key

    def translate_text(self, text, target_lang):
        data = {
            'auth_key': self.api_key,
            'text': text,
            'target_lang': target_lang
        }
        response = requests.post(self.api_url, data=data)
        if response.status_code == 200:
            result = response.json()
            return result['translations'][0]['text']
        else:
            print(f"DeepL API 호출 오류: {response.status_code}")
            return text


if __name__ == '__main__':
    res = ClovaSpeechClient().req_upload(file='video.mp4', completion='sync')

    # 응답을 다양한 형식으로 저장
    ClovaSpeechClient().save_response_to_json(res, 'response.json')
    ClovaSpeechClient().save_response_to_srt(res, 'response.srt')
    ClovaSpeechClient().save_response_to_txt(res, 'response.txt')
    ClovaSpeechClient().save_response_to_csv(res, 'response.csv')